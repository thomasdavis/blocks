---
title: Introduction
description: Domain-driven validation and orchestration for agentic coding workflows
---

# Introduction to Blocks

**Domain-driven validation and orchestration for agentic coding workflows**

Blocks is a system for controlling AI code generation through explicit domain semantics, multi-layer validation, and evolutionary design.

## Why Blocks?

Modern AI coding tools (Claude Code, Cursor, GPT engineers) generate code fast â€” but without a **design system**, output becomes inconsistent and unmaintainable.

Blocks provides:

- **Domain modeling** (entities, signals, measures â€” like Cube.dev/Malloy for code)
- **Multi-validator pipelines** (schema, shape, lint, domain, chain, shadow, scoring)
- **Agent orchestration** (AI reads spec, writes code, validates, learns from feedback)
- **Spec evolution** (detect domain drift, update spec or code)

## Key Features

### Domain Modeling

Define your domain semantics in `blocks.yml`:

- **Entities** - the "things" in your system
- **Signals** - domain concepts to extract
- **Measures** - constraints on outputs
- **Philosophy** - design principles

### Multi-Layer Validation

**Blocks is a development-time validator** that analyzes source code, not runtime behavior.

Four validator types:

1. **Schema** - Fast, structural validation of I/O signatures
2. **Shape** - Fast, file-based validation of structure
3. **Domain** - AI-powered semantic validation of ALL source files
4. **Output** - User-defined validators that render and check output (future)

### Agentic Integration

Works seamlessly with Claude Code, Cursor, and other AI coding tools:

1. Agent reads `blocks.yml`
2. Agent writes code
3. Agent runs `blocks run <name>`
4. Agent interprets validator output
5. Agent fixes issues and re-runs

### Spec Evolution

Detects when code introduces new concepts and proposes spec updates:

```
âš  [domain] Undocumented output field: alerts_es
â†’ Suggestion: Add alerts_es to outputs in blocks.yml
```

## Quick Example

Here's a simple block that calculates user engagement scores:

```yaml title="blocks.yml"
domain:
  entities:
    user:
      fields: [id, name, email]

  measures:
    score_0_1:
      constraints:
        - "Value must be between 0 and 1."

blocks:
  user_engagement_score:
    description: "Calculate user engagement score"
    inputs:
      - name: user
        type: entity.user
    outputs:
      - name: score
        type: measure.score_0_1
```

```typescript title="blocks/user_engagement_score/block.ts"
export async function userEngagementScore(user: any) {
  // Calculate engagement based on user activity
  const score = calculateEngagement(user);

  return { score };
}
```

Run validation:

```bash
blocks run user_engagement_score
```

Output:

```
ðŸ§± Blocks Validator

ðŸ“¦ Validating: user_engagement_score
  âœ“ schema ok
  âœ“ shape ok
  âœ“ domain ok

  âœ… Block "user_engagement_score" passed all validations
```

## Next Steps

<Cards>
  <Card
    title="Installation"
    description="Get started with Blocks in your project"
    href="/docs/getting-started/installation"
  />
  <Card
    title="Quick Start"
    description="Create your first block in 5 minutes"
    href="/docs/getting-started/quick-start"
  />
  <Card
    title="Core Concepts"
    description="Understand domain modeling and validation"
    href="/docs/core-concepts"
  />
  <Card
    title="Examples"
    description="Explore real-world examples"
    href="/docs/examples"
  />
</Cards>
