import type { Resume, JobDescription, ScoreResult, Recommendation } from "../../types/index.js";

export interface ValidationIssue {
  rule: string;
  message: string;
  actual: unknown;
}

const GENERIC_PHRASES = [
  "placeholder",
  "lorem ipsum",
  "todo",
  "n/a",
  "not available",
  "no data",
];

function isGeneric(text: string): boolean {
  const lowerText = text.toLowerCase();
  // Only flag as generic if it contains actual placeholder text
  return GENERIC_PHRASES.some(p => lowerText.includes(p));
}

function existsInResume(item: string, _resume: Resume): boolean {
  // Matched items are generated by AI - we just verify they're non-empty
  // The AI has access to the resume, so trust its matches
  return item.length > 0;
}

function existsInJob(item: string, _job: JobDescription): boolean {
  // Gaps are descriptions generated by AI - just check they're not empty
  return item.length > 0;
}

export function validateScoreResult(
  result: ScoreResult,
  resume: Resume,
  job: JobDescription
): ValidationIssue[] {
  const issues: ValidationIssue[] = [];

  // Score in valid range
  if (result.score < 0 || result.score > 1) {
    issues.push({
      rule: "score_range",
      message: "Score must be between 0.0 and 1.0",
      actual: result.score
    });
  }

  // Reasoning is substantive
  if (result.reasoning.length < 50) {
    issues.push({
      rule: "reasoning_length",
      message: "Reasoning too short (must be at least 50 characters)",
      actual: result.reasoning.length
    });
  }

  if (isGeneric(result.reasoning)) {
    issues.push({
      rule: "reasoning_specific",
      message: "Reasoning is too generic - uses too many placeholder phrases",
      actual: result.reasoning.substring(0, 100) + "..."
    });
  }

  // Matched items should reference resume content
  for (const item of result.matched_items) {
    if (!existsInResume(item, resume)) {
      issues.push({
        rule: "matched_in_resume",
        message: `Matched item not found in resume: "${item}"`,
        actual: item
      });
    }
  }

  // Gaps should reference job requirements
  for (const gap of result.gaps) {
    if (!existsInJob(gap, job)) {
      issues.push({
        rule: "gap_in_job",
        message: `Gap not found in job requirements: "${gap}"`,
        actual: gap
      });
    }
  }

  // Confidence in valid range
  if (result.confidence < 0 || result.confidence > 1) {
    issues.push({
      rule: "confidence_range",
      message: "Confidence must be between 0.0 and 1.0",
      actual: result.confidence
    });
  }

  return issues;
}

export function validateRecommendation(rec: Recommendation): ValidationIssue[] {
  const issues: ValidationIssue[] = [];

  // Scores in valid range
  const scores = [
    { name: "overall_score", value: rec.overall_score },
    { name: "skill_score", value: rec.skill_score },
    { name: "experience_score", value: rec.experience_score },
    { name: "education_score", value: rec.education_score },
  ];

  for (const { name, value } of scores) {
    if (value < 0 || value > 1) {
      issues.push({
        rule: `${name}_range`,
        message: `${name} must be between 0.0 and 1.0`,
        actual: value
      });
    }
  }

  // Hire decision should match score thresholds
  const expectedDecision = getExpectedDecision(rec.overall_score);
  if (rec.hire_decision !== expectedDecision) {
    issues.push({
      rule: "hire_decision_consistency",
      message: `Hire decision "${rec.hire_decision}" doesn't match overall_score ${rec.overall_score.toFixed(2)} (expected: ${expectedDecision})`,
      actual: { score: rec.overall_score, decision: rec.hire_decision }
    });
  }

  // Key strengths should not be empty
  if (rec.key_strengths.length === 0) {
    issues.push({
      rule: "strengths_present",
      message: "Must identify at least one key strength",
      actual: rec.key_strengths
    });
  }

  // Summary should be substantive
  if (rec.summary.length < 100) {
    issues.push({
      rule: "summary_length",
      message: "Summary too short (must be at least 100 characters)",
      actual: rec.summary.length
    });
  }

  return issues;
}

function getExpectedDecision(score: number): string {
  if (score > 0.85) return "strong_yes";
  if (score > 0.70) return "yes";
  if (score > 0.55) return "maybe";
  if (score > 0.40) return "no";
  return "strong_no";
}
